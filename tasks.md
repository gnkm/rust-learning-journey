# Rust学習計画（100タスク）

## レベル3到達：Rust環境構築と基礎（タスク1-25）

### 環境構築（1-5）
- [x] 1. **Rust開発環境のセットアップ** - rustupをインストールし、rustc --versionで確認
- [ ] 2. **Cursorの設定** - rust-analyzerプラグインのインストールと設定
- [x] 3. **Git リポジトリ初期化** - rust-learning-journeyリポジトリを作成、.gitignore設定
- [x] 4. **Cargoの基本** - cargo new hello_worldでプロジェクト作成、ディレクトリ構造を理解
- [x] 5. **初めてのビルドと実行** - cargo build、cargo run、cargo checkの違いを体験

### 基本構文（6-15）
- [ ] 6. **Hello, World!** - println!マクロを使った出力、マクロの概念理解
- [ ] 7. **変数の束縛** - let、let mut、シャドーイングの練習
- [ ] 8. **基本データ型1** - 整数型（i32、u32など）、型推論の確認
- [ ] 9. **基本データ型2** - 浮動小数点、bool、charの使用
- [ ] 10. **型注釈** - 明示的な型指定、型変換（as）の練習
- [ ] 11. **定数と静的変数** - const、staticの違いと使い方
- [ ] 12. **算術演算と比較** - 基本的な演算子、オーバーフロー時の動作確認
- [ ] 13. **文字列の基礎** - String と &str の初歩的な使い分け
- [ ] 14. **標準入力** - std::ioを使った入力処理
- [ ] 15. **簡単な電卓** - 入力を受けて四則演算を行うプログラム

### 制御構造（16-20）
- [ ] 16. **if式** - if/else、if式の値を返す書き方
- [ ] 17. **loop文** - 無限ループとbreak、continueの使用
- [ ] 18. **while文** - 条件付きループの実装
- [ ] 19. **for文** - rangeを使った反復処理
- [ ] 20. **match式の基礎** - 数値のパターンマッチング

### 関数とコメント（21-25）
- [ ] 21. **関数定義** - 引数と戻り値のある関数作成
- [ ] 22. **式と文** - セミコロンの有無による違いの理解
- [ ] 23. **ドキュメントコメント** - ///を使ったコメント、cargo doc生成
- [ ] 24. **ユニットテストの基礎** - #[test]、assert!マクロの使用
- [ ] 25. **FizzBuzzで総復習** - ここまでの知識でFizzBuzzを実装

**確認テスト1**: 基本構文、変数、制御構造、関数の理解度確認

---

## レベル4到達：構造体とエラーハンドリング（タスク26-45）

### データ構造（26-35）
- [ ] 26. **タプル** - 複数の値をまとめる、パターンマッチングでの分解
- [ ] 27. **配列とスライス** - 固定長配列、スライスの参照
- [ ] 28. **ベクタの基礎** - Vec<T>の作成、push、pop操作
- [ ] 29. **構造体定義** - struct定義、フィールドアクセス
- [ ] 30. **構造体メソッド** - impl、self、&self、&mut selfの違い
- [ ] 31. **タプル構造体** - newtype patternの理解
- [ ] 32. **列挙型の基礎** - enumの定義と使用
- [ ] 33. **Option型** - Some/Noneの概念、unwrapの危険性
- [ ] 34. **Result型の基礎** - Ok/Errでのエラーハンドリング
- [ ] 35. **HashMapの使用** - キーバリューストアの基本操作

### パターンマッチング（36-40）
- [ ] 36. **matchの応用** - 複数パターン、ガード条件
- [ ] 37. **if let** - 単一パターンの簡潔な書き方
- [ ] 38. **while let** - パターンマッチングを使ったループ
- [ ] 39. **構造体の分解** - パターンマッチングでフィールド取得
- [ ] 40. **ref と ref mut** - パターン内での参照取得

### モジュールとクレート（41-45）
- [ ] 41. **モジュール作成** - mod、pub、useの基本
- [ ] 42. **ファイル分割** - 別ファイルでのモジュール定義
- [ ] 43. **外部クレート使用** - Cargo.tomlへの依存追加（serde）
- [ ] 44. **プライバシールール** - pub(crate)、pub(super)の理解
- [ ] 45. **簡単なCLIツール** - clapクレートを使った引数パース

**確認テスト2**: 構造体、列挙型、エラーハンドリング、モジュールシステムの理解度確認

---

## レベル5到達：所有権システムの習得（タスク46-65）

### 所有権の基礎（46-55）
- [ ] 46. **所有権の概念** - ムーブセマンティクスの理解
- [ ] 47. **Copy trait** - Copy型とムーブ型の違い
- [ ] 48. **関数と所有権** - 引数での所有権移動
- [ ] 49. **戻り値と所有権** - 所有権を返す関数
- [ ] 50. **参照と借用** - &による不変借用
- [ ] 51. **可変参照** - &mutによる可変借用
- [ ] 52. **借用ルール** - 複数の不変参照、単一の可変参照
- [ ] 53. **スライス参照** - 文字列スライス、配列スライス
- [ ] 54. **ダングリング参照** - コンパイラがどう防ぐか理解
- [ ] 55. **所有権パズル** - 複雑な所有権問題を解く練習

### ライフタイム（56-65）
- [ ] 56. **ライフタイム注釈の基礎** - 'aの意味と必要性
- [ ] 57. **関数のライフタイム** - 引数と戻り値のライフタイム関係
- [ ] 58. **構造体のライフタイム** - 参照を含む構造体
- [ ] 59. **ライフタイム省略規則** - 3つの省略規則の理解
- [ ] 60. **'static ライフタイム** - プログラム全体で有効な参照
- [ ] 61. **複数ライフタイム** - 'a と 'b の関係性
- [ ] 62. **ライフタイムとジェネリクス** - <'a, T>の組み合わせ
- [ ] 63. **メソッドのライフタイム** - implブロックでのライフタイム
- [ ] 64. **ライフタイムサブタイピング** - 'a: 'bの意味
- [ ] 65. **複雑なライフタイム演習** - 実践的な問題を解く

**確認テスト3**: 所有権、借用、ライフタイムの完全理解確認

---

## レベル6到達：中級機能の習得（タスク66-85）

### トレイトとジェネリクス（66-75）
- [ ] 66. **トレイト定義** - trait定義と実装
- [ ] 67. **デフォルト実装** - トレイトメソッドのデフォルト動作
- [ ] 68. **トレイト境界** - T: Displayなどの制約
- [ ] 69. **ジェネリック関数** - 型パラメータを持つ関数
- [ ] 70. **ジェネリック構造体** - Option<T>のような実装
- [ ] 71. **Associated Types** - トレイトの関連型
- [ ] 72. **トレイトオブジェクト** - Box<dyn Trait>の使用
- [ ] 73. **Derive マクロ** - Debug、Clone、PartialEqの自動実装
- [ ] 74. **カスタムトレイト** - Displayトレイトの手動実装
- [ ] 75. **高階トレイト境界** - where句を使った複雑な制約

### 高度なエラーハンドリング（76-80）
- [ ] 76. **カスタムエラー型** - 独自のError enum定義
- [ ] 77. **thiserrorクレート** - エラー型の簡潔な定義
- [ ] 78. **anyhowクレート** - コンテキスト付きエラー
- [ ] 79. **? 演算子の活用** - エラー伝播の効率化
- [ ] 80. **エラーチェイン** - 複数のエラー型の変換

### イテレータとクロージャ（81-85）
- [ ] 81. **クロージャの基礎** - |x| x + 1 の構文
- [ ] 82. **ムーブクロージャ** - moveキーワードの使用
- [ ] 83. **イテレータメソッド** - map、filter、fold
- [ ] 84. **カスタムイテレータ** - Iterator traitの実装
- [ ] 85. **イテレータの組み合わせ** - チェインによる処理

**確認テスト4**: トレイト、ジェネリクス、高度なエラーハンドリングの理解度確認

---

## レベル7到達：非同期プログラミングと実践（タスク86-100）

### 非同期プログラミング基礎（86-92）
- [ ] 86. **async/await入門** - 非同期関数の定義
- [ ] 87. **Tokioランタイム** - #[tokio::main]の使用
- [ ] 88. **非同期タスク** - tokio::spawnでタスク生成
- [ ] 89. **非同期チャネル** - mpscでの通信
- [ ] 90. **select!マクロ** - 複数の非同期操作の選択
- [ ] 91. **タイムアウト処理** - timeout関数の使用
- [ ] 92. **並行実行** - join!での同時実行

### マルチエージェントシステム構築（93-100）
- [ ] 93. **エージェント構造体設計** - トレイトでエージェント抽象化
- [ ] 94. **メッセージパッシング** - エージェント間通信の実装
- [ ] 95. **状態管理** - Arc<Mutex<T>>での共有状態
- [ ] 96. **エージェントループ** - 各エージェントの実行ループ
- [ ] 97. **HTTPサーバー統合** - axumでREST API実装
- [ ] 98. **JSON通信** - serdeでのメッセージシリアライズ
- [ ] 99. **エラー処理統合** - システム全体のエラー設計
- [ ] 100. **統合テスト作成** - マルチエージェントシステムの動作確認

**確認テスト5**: 非同期プログラミング、並行処理、システム設計の理解度確認

---

## 理解度テストのテーマ

1. **確認テスト1**（タスク25後）: 変数束縛、基本型、制御構造、関数
2. **確認テスト2**（タスク45後）: 構造体、列挙型、Result/Option、モジュール
3. **確認テスト3**（タスク65後）: 所有権ルール、借用チェッカー、ライフタイム
4. **確認テスト4**（タスク85後）: トレイト設計、ジェネリクス、エラー設計
5. **確認テスト5**（タスク100後）: 非同期処理、並行性、システムアーキテクチャ

各テストは100点満点で、80点以上で次のレベルへ進み、80点未満の場合は弱点補強タスクを追加します。

## 参考: レベル定義

レベル 1：プログラミング未経験者
	•	できること
	•	コンピュータで何かを「動かす」手順（プログラム）の考え方そのものに触れたことがない。
	•	キーボードやテキストエディタを使ってコードを書く経験がない。
	•	「変数」「条件分岐」「ループ」「関数」などの概念を理解していない。
	•	持っている知識
	•	コンピュータの仕組みやOSの使い方は一般的ユーザー程度（ファイル操作やアプリ起動など）。
	•	プログラミング言語についてはほぼゼロ。

⸻

レベル 2：プログラミング入門レベル
	•	できること
	•	“プログラムとは何か”という基本概念は何となく理解している（「命令の集合」「アルゴリズム」など）。
	•	簡単な擬似コードを書くことができる（「もし〜なら〜する」といった条件分岐のイメージ）。
	•	テキストエディタやIDE（VSCodeなど）の基本操作を使い始めている。
	•	文字列の入出力（標準入力から文字列を読み込む／画面に文字列を出力する）を試したことがある。
	•	持っている知識
	•	変数やデータ型（整数・文字列など）の概念を学習している。
	•	条件分岐（if/else）やループ（for/while）の基本的な使い方を学習済み（ただし実践経験は浅い）。
	•	関数／メソッドの呼び出しと定義方法を一度は試したことがある。
	•	メモリ管理（所有権／借用など）やモジュール分割はまだ未経験。

⸻

レベル 3：Rustの基礎を触ったことがある初心者
	•	できること
	•	Rust の開発環境（rustup、Cargo）のセットアップ方法を理解し、自力でインストールできる。
	•	cargo new でプロジェクトを作成し、cargo build／cargo run が成功するレベル。
	•	println! マクロを使って「Hello, world!」を表示した経験がある。
	•	基本的なデータ型（整数型、浮動小数点型、文字列型、ブーリアン型）を使って簡単な演算ができる。
	•	変数の束縛（let／let mut）の違いを理解し、可変・不変の変数を使い分けられる。
	•	持っている知識
	•	if や match を使った簡単な条件分岐が書ける。
	•	for、while ループを使って配列やベクタを反復処理した経験がある。
	•	関数（fn）の定義と呼び出しは概ね理解しているが、引数のライフタイム注釈（'a）や複雑な戻り値はまだ学習途中。
	•	所有権システム（Ownership）の概要を聞いたことがあるが、実際の借用ルール（Borrow Checker）が出すエラーはまだ直感的にわからない。

⸻

レベル 4：Rustの構文と基礎文法はひと通り使える
	•	できること
	•	所有権（Ownership）と借用（Borrowing）の基本ルール（ムーブとコピーの違い）を理解し、それに沿ったコードが書ける。
	•	String と &str の違いや、ヒープ／スタックの概念を知っている。
	•	構造体（struct）や列挙型（enum）を定義し、パターンマッチ（match）で分岐処理できる。
	•	モジュール（mod）を使い、複数ファイルに分けたプロジェクト構成を試したことがある。
	•	基本的なエラーハンドリング（Result<T, E> と Option<T> の使い分け）を学び、? 演算子を使った簡易エラープロパゲーションができる。
	•	持っている知識
	•	標準ライブラリ（std::vec::Vec、HashMap、Result、Option など）の代表的な型をひととおり把握している。
	•	Cargo.toml に依存クレートを追加し、外部ライブラリ（crates.io）をインストールして使った経験がある。
	•	Rust公式ドキュメント（The Rust Programming Language、Rust By Example）を辞書的に参照しながら学習できる。
	•	テストフレームワーク（#[test] アトリビュートを使ったユニットテスト）の書き方を理解し、簡単なテストを書いたことがある。

⸻

レベル 5：所有権・借用・ライフタイムを実践的に使える中級の入口
	•	できること
	•	所有権／借用エラー（コンパイル時のムーブ・ダングリングチェック）を自力で解読し、修正できる。
	•	ライフタイム注釈（<'a>）を理解し、関数シグネチャに明示的なライフタイムを指定して複数参照を正しく扱える。
	•	構造体内に参照を持たせる（struct Foo<'a> { data: &'a str } のようなコード）を書いたことがある。
	•	ジェネリクス（T: SomeTrait）、トレイトバウンド（where T: Debug）を使って汎用的な関数や構造体を実装できる。
	•	エラーハンドリングで自作エラー型（enum MyError { … }）を定義し、thiserror や anyhow などのクレートを使いこなせる。
	•	持っている知識
	•	標準ライブラリのコレクション（Vec<T>, HashMap<K, V>, LinkedList<T> など）やイテレータ（iter(), map(), filter()）の仕組みを理解し、イテレータチェインによるデータ処理ができる。
	•	クレート（crate）とモジュール（module）の違い、および複数クレートを使ったプロジェクト構成を経験済み。
	•	ドキュメントコメント（///）やドキュメンテーションテスト（`/// rust ... ）を使ってAPIドキュメントを生成できる。
	•	cargo fmt、cargo clippy を用いてコードフォーマット・静的解析を行い、Rustらしい（idiomatic な）コードを書こうと意識している。

⸻

レベル 6：中級者相当の基礎力がある
	•	できること
	•	モジュール階層やパブリック／プライベート（pub／非 pub）の概念を意識し、ライブラリクレート（lib.rs）とバイナリクレート（main.rs）を一つのワークスペースで管理できる。
	•	トレイト（trait）を定義し、複数の型に対して共通の振る舞いを実装するデザインパターンを使いこなせる。
	•	複数のライフタイムを伴う関数シグネチャ（fn foo<'a, 'b>(x: &'a str, y: &'b mut String) -> &'a str など）を理解し、正しい生存期間を構築できる。
	•	標準ライブラリを越える外部クレート（serde でのシリアライズ／デシリアライズ、reqwest でのHTTPリクエストなど）を使って、一つの小規模プロジェクト（例：JSON APIクライアント）を作成したことがある。
	•	マクロ（macro_rules!）の基礎を学び、自前でシンプルなマクロを定義して繰り返しコードを削減できる。
	•	持っている知識
	•	Result<T, E> の map/and_then チェイン、あるいは Option<T> の unwrap_or/unwrap_or_else といったメソッドを使いこなし、エラー処理のフローを簡潔に書ける。
	•	Trait オブジェクト（Box<dyn SomeTrait>）の概念を理解し、動的ディスパッチを必要とする場面で適切に使えている。
	•	シリアライズ・デシリアライズ（serde_json::to_string／from_str）を使って、複雑な構造体を JSON や YAML に変換する実装経験がある。
	•	テストフレームワークを深く使い、モック（mockall など）を利用したモジュール単位のテストを書ける。

⸻

レベル 7：Rust を使った中規模開発ができる
	•	できること
	•	非同期プログラミング（async/await）の基本を理解し、Tokio や async-std を使って簡易的な非同期タスク（HTTP サーバー、チャットサーバーなど）を構築できる。
	•	futures について概要を把握し、ストリーム（Stream トレイト）や select! マクロを用いた複数タスクの制御を経験している。
	•	プロジェクトの依存管理に Cargo.lock の仕組みやワークスペース（[workspace]）構成を理解し、複数のクレートを横断してバージョンを統一できる。
	•	デザインパターン（Builder パターン、Factory パターンなど）を Rust 流に落とし込み、コードの可読性・保守性を意識した設計ができる。
	•	AST 操作や procedural macro（プロシージャルマクロ）の基本的な仕組みを知り、自前の derive マクロを最小限構築できる。
	•	持っている知識
	•	unsafe ブロックの意味を理解し、ごく簡単な unsafe コード（生ポインタの参照や外部 C ライブラリとの連携）を書いた経験がある。
	•	Windows／macOS／Linux など複数プラットフォーム上でのクロスコンパイル（cargo build --target）の方法を把握し、簡単なマルチプラットフォームバイナリを生成できる。
	•	プロファイラ（perf、cargo bench、criterion）を使ったベンチマーク測定を経験し、ボトルネックを把握する手順を理解している。
	•	ドキュメント生成（cargo doc）を使い、公開用クレートのドキュメントサイトを自作して GitHub Pages などでホスティングしたことがある。

⸻

レベル 8：Rust を用いた大規模開発・深い理解がある
	•	できること
	•	大規模プロジェクトでのモジュール設計やライブラリ分割を自力で設計し、CI/CD パイプライン（GitHub Actions、GitLab CI など）と連携して自動ビルド・テストを構築できる。
	•	高度な並行処理（async タスク間のチャネル通信、tokio::sync の各種同期プリミティブ、スレッドプール実装など）を自力で設計・実装できる。
	•	Pin/Unpin、Arc/Mutex/RwLock などのスマートポインタ・同期オブジェクトを適切に選択し、安全にマルチスレッド環境を構築できる。
	•	unsafe コードを使わざるを得ない場面（FFI 連携、ハイパフォーマンス向け最適化）で、自分の書いた unsafe 部分が未定義動作（undefined behavior）を起こさないよう検証しつつ実装できる。
	•	プロシージャルマクロを本格的に活用し、デリゲートコードや自動生成コードを自前で書き、コードの重複をなくす仕組みを構築できる。
	•	持っている知識
	•	Rust のメモリモデルとライフタイム解析アルゴリズム（Borrow Checker）がどのように内部で動いているか、大まかな仕組みを把握している。
	•	コンパイラ内部（rustc）の一部モジュールやミドルウェア（例：LLVM）との連携について概要を理解し、簡単なコンパイラプラグインや linter を自作した経験がある。
	•	WebAssembly（wasm）向けに Rust コードをビルドし、ブラウザや Node.js 環境で動かす方法を熟知している。
	•	セキュリティ面（DevSecOps）の観点から、メモリ安全性や境界チェック、省略された初期化パターンのリスクを深く理解し、コードレビューや脆弱性診断がある程度できる。
	•	高度なベンチマーク／プロファイリングツール（perf, flamegraph, heaptrack など）を使いこなし、メモリレイアウト・キャッシュ効率まで考慮した最適化ができる。

⸻

レベル 9：Rust エキスパートに近い
	•	できること
	•	Rust のコアライブラリ開発（標準ライブラリへの機能追加、クレートのメンテナンス）にコントリビュートできるレベル。
	•	Rust コンパイラ（rustc）やツールチェイン（cargo、rustfmt、clippy など）の内部実装を読めて、簡単な修正や改善提案ができる。
	•	ローレベル最適化（SIMD 命令の利用、メモリレイアウトのチューニング、キャッシュヒット率最適化）を意識し、マイクロベンチマークを自作して効果を検証できる。
	•	大規模なプロシージャルマクロ（例：ドメイン固有言語 DSL の構築）を設計し、公開レベルのクレートとして OSS に提供できる。
	•	ゼロコスト抽象化（Zero-cost Abstraction）の原理を自力で説明でき、用途に応じて柔軟に設計を組み立てられる。
	•	持っている知識
	•	Rust 言語仕様（RFC）を読みこなし、これから提案される機能（提案段階の RFC）を追いかけている。
	•	内部メモリモデル（所有権／借用システム）のアルゴリズムレベルの理解がある。
	•	LLVM IR や MIR（中間表現）をコーディングやパフォーマンスチューニングに活用し、自分で MIR レベルの最適化やLintプラグインを作った経験がある。
	•	アーキテクチャ全体（コンパイラ、ビルドシステム、ドキュメント生成ツールなど）の連携フローを隅々まで把握している。
	•	コミュニティ活動（RustConf やローカルミートアップで登壇、ブログ記事・技術書の執筆、Rustの日本語翻訳やドキュメント改善など）を行っている。

⸻

レベル 10：Rust 習熟者（トップエキスパート）
	•	できること
	•	Rust 言語そのものの設計原則やトレードオフ（所有権システム、ライフタイム推論、型システム拡張など）を他人に明快に教えられる。
	•	コンパイラやランタイムのコア機能開発に完全にキャッチアップし、自分で言語機能を設計して RFC として提出し、実装まで行える。
	•	業界標準クラスライブラリ（Tokio、actix-web、Rocket、Serde、Diesel など）の作者やコアコントリビュータレベルで、主要プロジェクトに深く関わっている。
	•	高度なシステムプログラミング分野（OSカーネル拡張、ドライバ開発、組み込みリアルタイムシステム、分散システムのコア部分）に Rust を用いている。
	•	学術的・産業的に「Rust の限界」を知り、その上で最適解を選ぶ判断力があり、ゼロコスト抽象化を極限まで追求したライブラリ設計が行える。
	•	持っている知識
	•	Rust コンパイラの内部動作（パーサー、タイプチェッカー、借用チェッカー、MIR最適化、LLVMバックエンド）を詳細に理解している。
	•	Rust のメモリ保証や型システムのセキュリティ理論（例えば、所有権の型安全性証明や型システム拡張の理論的背景）を理解・研究した経験がある。
	•	大規模プロジェクトでの運用ノウハウ（バージョンアップ戦略、互換性維持、クレートエコシステムの最適化など）をマネジメントレベルで提案・実施できる。
	•	クロス言語連携（C/C++、Python、Java など）での FFI 設計、ABI 安全性の保証、CI/CD パイプラインでの自動テストをフルスタックで構築・運用できる。
	•	コミュニティリーダーとして、Rust のロードマップ策定や言語仕様改善にコミットし、技術書籍や論文も執筆・監修している。
