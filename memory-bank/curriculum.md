## Rust 学習計画（レベル7到達目標）

### 学習方針

1.  **基礎の徹底:** Rust の最重要概念である所有権、借用、ライフタイムを重点的に学習します。
2.  **実践重視:** 各フェーズで小さなプログラムを作成し、手を動かしながら理解を深めます。興味のある CLI ツール作成をマイルストーンとします。
3.  **Rustらしさの追求:** `cargo fmt` や `cargo clippy` を活用し、イディオマティックな Rust コードを書くことを意識します。エラーメッセージとの対話も重要な学習プロセスです。
4.  **段階的ステップアップ:** レベル定義に基づき、着実にステップアップできるようタスクを構成します。
5.  **ドキュメント活用:** 公式ドキュメント（The Rust Programming Language, Rust by Example など）を積極的に参照します。

### 学習フェーズと期間の目安

あくまで目安ですが、集中的に取り組む場合、各フェーズに以下の時間を想定しています。

  * **フェーズ1: Rust の第一歩と環境構築** (目標: レベル3) - 約1週間
  * **フェーズ2: 所有権・データ構造・エラー処理の基礎** (目標: レベル4) - 約2-3週間
  * **フェーズ3: ライフタイム・ジェネリクス・トレイトによる抽象化** (目標: レベル5) - 約3-4週間
  * **フェーズ4: クレート活用とプロジェクト構成** (目標: レベル6) - 約3-4週間
  * **フェーズ5: 非同期プログラミングと高度なトピック入門** (目標: レベル7) - 約4-5週間

-----

### タスクリスト

#### Git 管理

  * **タスク 0: Git 準備**
      * **なぜ学ぶのか:** 学習の進捗と成果物を一元管理するため。
      * **何を学ぶのか:** Git リポジトリの作成と基本的な操作。
      * **何をするのか:**
        1.  `rust_learning`のような名前でローカルにディレクトリを作成する。
        2.  そのディレクトリで `git init` を実行し、Git リポジトリを作成する。
        3.  必要であれば、GitHubなどのリモートリポジトリを作成し、ローカルリポジトリと連携する。
        4.  この学習計画を記述した `README.md` ファイルを作成し、最初のコミットを行う。
      * **目標レベル:** - (準備)

-----

#### フェーズ1: Rust の第一歩と環境構築 (目標: レベル3)

  * **タスク 1: Rust開発環境のセットアップ**

      * **なぜ学ぶのか:** Rust プログラムを作成、コンパイル、実行するための基本的なツールを導入するため。
      * **何を学ぶのか:** `rustup` (Rustツールチェインマネージャー) のインストールと使い方、`cargo` (Rustのビルドシステム兼パッケージマネージャー) の役割。
      * **何をするのか:**
        1.  [rustup.rs](https://rustup.rs/) の指示に従い、`rustup` をインストールする。
        2.  ターミナルで `rustc --version` および `cargo --version` を実行し、正しくインストールされたことを確認する。
        3.  Cursor (VSCodeベース) に `rust-analyzer` 拡張機能をインストールし、設定を確認する。
      * **目標レベル:** 3

  * **タスク 2: 初めてのRustプログラム (Hello, world\!)**

      * **なぜ学ぶのか:** `cargo` を使ったプロジェクト作成、ビルド、実行の一連の流れを体験するため。
      * **何を学ぶのか:** `cargo new`, `cargo build`, `cargo run` コマンド、`main.rs` ファイルと `main` 関数の役割、`println!` マクロ。
      * **何をするのか:**
        1.  `cargo new hello_world` コマンドで新しいプロジェクトを作成する。
        2.  生成された `src/main.rs` を開き、`println!("Hello, world!");` となっていることを確認する。
        3.  `cd hello_world` でプロジェクトディレクトリに移動し、`cargo run` を実行して "Hello, world\!" が表示されることを確認する。
      * **目標レベル:** 3

  * **タスク 3: 基本的なデータ型と変数束縛 (整数型、浮動小数点型)**

      * **なぜ学ぶのか:** 数値を扱うための基本的な型と、値を名前を付けて保存する方法を理解するため。
      * **何を学ぶのか:** 整数型 (`i32`, `u64` 等)、浮動小数点型 (`f32`, `f64`)、`let` による変数束縛、型推論、型アノテーション。
      * **何をするのか:**
        1.  `hello_world` プロジェクトの `main` 関数内で、整数型と浮動小数点型の変数をいくつか宣言し、`println!` で値を表示する。
        2.  型アノテーションを明示的に指定する場合と、型推論に任せる場合を試す。
      * **目標レベル:** 3

  * **タスク 4: 基本的なデータ型と変数束縛 (ブーリアン型、文字型)**

      * **なぜ学ぶのか:** 真偽値や単一文字を扱う型を理解するため。
      * **何を学ぶのか:** ブーリアン型 (`bool`)、文字型 (`char`)。
      * **何をするのか:**
        1.  `main` 関数内で、ブーリアン型と文字型の変数を宣言し、`println!` で値を表示する。
        2.  `char` 型が Unicode スカラー値を表現することを確認する (例: `'😻'`)。
      * **目標レベル:** 3

  * **タスク 5: 可変性と不変性**

      * **なぜ学ぶのか:** Rustの安全性の重要な特徴である、変数がデフォルトで不変であること、そして可変にする方法を理解するため。
      * **何を学ぶのか:** `let` (不変束縛) と `let mut` (可変束縛) の違い。
      * **何をするのか:**
        1.  `let` で束縛した変数に再代入しようとしてコンパイルエラーが発生することを確認する。
        2.  `let mut` を使って変数を可変にし、値を変更して表示するプログラムを書く。
      * **目標レベル:** 3

  * **タスク 6: 基本的な演算**

      * **なぜ学ぶのか:** 数値計算や論理演算を行う方法を学ぶため。
      * **何を学ぶのか:** 算術演算子 (`+`, `-`, `*`, `/`, `%`)、論理演算子 (`&&`, `||`, `!`)。
      * **何をするのか:**
        1.  `main` 関数内で、整数や浮動小数点数を使って四則演算や剰余演算を行い、結果を表示する。
        2.  ブーリアン値を使って論理演算を行い、結果を表示する。
      * **目標レベル:** 3

  * **タスク 7: 関数 (fn) の定義と呼び出し**

      * **なぜ学ぶのか:** コードを再利用可能なブロックに分割する方法を学ぶため。
      * **何を学ぶのか:** `fn` キーワードによる関数定義、引数と戻り値の型指定、関数の呼び出し方。
      * **何をするのか:**
        1.  簡単な計算 (例: 2つの数値を足す) を行う関数を定義し、`main` 関数から呼び出して結果を表示する。
        2.  戻り値がない関数も定義してみる。
      * **目標レベル:** 3

  * **タスク 8: コメント**

      * **なぜ学ぶのか:** コードの可読性を高め、他の人（や未来の自分）がコードを理解しやすくするため。
      * **何を学ぶのか:** 通常のコメント (`//`) とドキュメントコメント (`///`, `//!`) の基本的な使い方。
      * **何をするのか:**
        1.  これまでに書いたコードに、処理内容を説明するコメントを追加する。
        2.  簡単な関数にドキュメントコメントを追加してみる（現時点では生成はしない）。
      * **目標レベル:** 3

  * **タスク 9: 条件分岐 (if/else)**

      * **なぜ学ぶのか:** 条件に応じて異なる処理を実行する方法を学ぶため。
      * **何を学ぶのか:** `if`, `else if`, `else` 式の使い方、`if` が式であること。
      * **何をするのか:**
        1.  ある数値が正か負かゼロかを判定して表示するプログラムを書く。
        2.  `if` 式の結果を `let` で変数に束縛する例を試す。
      * **目標レベル:** 3

  * **タスク 10: ループ (loop, while, for)**

      * **なぜ学ぶのか:** 繰り返し処理を実行する方法を学ぶため。
      * **何を学ぶのか:** `loop` (無限ループと `break`)、`while` (条件付きループ)、`for` (コレクションの反復処理) の基本的な使い方。
      * **何をするのか:**
        1.  `loop` を使ってカウンターが特定の値になったら `break` するプログラムを書く。
        2.  `while` を使って同様のカウンタープログラムを書く。
        3.  簡単な数値の範囲 (`1..5`など) を `for` ループで反復処理し、値を表示する。
      * **目標レベル:** 3

  * **フェーズ1 確認テストのテーマ:**

      * Rust の開発環境セットアップ手順の説明。
      * 基本的なデータ型（整数、浮動小数点、ブーリアン、文字）の使い分け。
      * 変数束縛における `let` と `let mut` の違いの説明。
      * 簡単な関数を定義し、引数と戻り値を設定するコードの作成。
      * `if/else` および基本的なループ (`for`, `while`) を使った簡単な問題解決。
      * Git でここまでの変更をコミットする。

-----

#### フェーズ2: 所有権・データ構造・エラー処理の基礎 (目標: レベル4)

  * **タスク 11: 所有権 (Ownership) - ムーブ (Move)**

      * **なぜ学ぶのか:** Rustの最もユニークで中心的な概念である所有権システムの基本を理解するため。メモリ安全性を保証する仕組みの第一歩。
      * **何を学ぶのか:** 所有権の3つのルール、スタックとヒープの基本的な違い、値がスコープを抜けるとメモリが自動的に解放される仕組み、`String` 型のようなヒープにデータを持つ型でのムーブセマンティクス。
      * **何をするのか:**
        1.  `String` 型の変数を別の変数に束縛した際に、元の変数が無効になる（ムーブされる）ことを確認するコードを書く。コンパイルエラーを観察する。
        2.  関数に `String` を渡すと所有権が移動し、関数内でしか使えなくなることを確認する。
      * **目標レベル:** 4

  * **タスク 12: 所有権 (Ownership) - クローン (Clone)**

      * **なぜ学ぶのか:** ヒープ上のデータを明示的に複製し、複数の所有者を持たせる方法を学ぶため。
      * **何を学ぶのか:** `clone` メソッド、ムーブとの違い、パフォーマンスへの影響（ディープコピー）。
      * **何をするのか:**
        1.  `String` 型の変数に対し `clone` メソッドを使ってデータを複製し、元の変数と複製された変数の両方が有効であることを確認する。
        2.  関数に `String` のクローンを渡すことで、元の変数の所有権を保持する方法を試す。
      * **目標レベル:** 4

  * **タスク 13: 所有権 (Ownership) - コピー (Copy) トレイト**

      * **なぜ学ぶのか:** スタック上のみにデータを持つ型が、どのように暗黙的にコピーされるかを理解するため。
      * **何を学ぶのか:** `Copy` トレイト、`Copy` トレイトを持つ型 (整数型、ブーリアン型、`char` 型など) の挙動、`Clone` と `Copy` の関係。
      * **何をするのか:**
        1.  整数型などの `Copy` トレイトを持つ型の変数を別の変数に束縛した際に、元の変数も引き続き有効である（コピーされる）ことを確認するコードを書く。
        2.  自作の単純な構造体に `Copy` と `Clone` を `derive` してみる（構造体の詳細は後述）。
      * **目標レベル:** 4

  * **タスク 14: 参照 (References) と借用 (Borrowing) - 不変参照**

      * **なぜ学ぶのか:** 所有権を移動させずに値にアクセスする方法を学ぶため。メモリ効率と安全性を両立させる重要な仕組み。
      * **何を学ぶのか:** `&` 記号による不変参照の作成、参照は値を所有しないこと、複数の不変参照は同時に存在できること。
      * **何をするのか:**
        1.  `String` 型の値への不変参照を作成し、関数にその参照を渡して値を読み取るコードを書く。元の `String` の所有権が移動しないことを確認する。
        2.  一つのデータに対して複数の不変参照を作成できることを試す。
      * **目標レベル:** 4

  * **タスク 15: 参照 (References) と借用 (Borrowing) - 可変参照**

      * **なぜ学ぶのか:** 所有権を移動させずに値を変更する方法を学ぶため。
      * **何を学ぶのか:** `&mut` 記号による可変参照の作成、可変参照は特定のスコープで一つしか存在できないルール（データ競合を防ぐため）。
      * **何をするのか:**
        1.  `String` 型の値への可変参照を作成し、関数にその参照を渡して値を変更するコードを書く。
        2.  同じスコープ内で同じデータへの可変参照を複数作ろうとしたり、可変参照と不変参照を同時に作ろうとしてコンパイルエラーが発生することを確認する。
      * **目標レベル:** 4

  * **タスク 16: ダングリング参照の防止**

      * **なぜ学ぶのか:** Rust のコンパイラが、無効なメモリを指す参照（ダングリング参照）をどのようにコンパイル時に防ぐかを理解するため。
      * **何を学ぶのか:** 参照のライフタイムとスコープの関係、コンパイラによるチェック。
      * **何をするのか:**
        1.  スコープを抜けて解放されるデータへの参照を返そうとする関数を書き、コンパイルエラーが発生することを確認する（ライフタイムの導入はまだ）。
        2.  エラーメッセージを読み、なぜそれが問題なのかを理解する。
      * **目標レベル:** 4

  * **タスク 17: スライス (Slices) - 文字列スライス**

      * **なぜ学ぶのか:** `String` の一部分への参照を安全に扱う方法を学ぶため。
      * **何を学ぶのか:** 文字列スライス (`&str`) 型、`String` からスライスを作成する方法、スライスは所有権を持たないこと。
      * **何をするのか:**
        1.  `String` を作成し、その一部分を指す文字列スライスを作成する。
        2.  文字列スライスを引数に取る関数を作成し、`String` と文字列リテラル (`"hello"`) の両方を渡せることを確認する。
      * **目標レベル:** 4

  * **タスク 18: スライス (Slices) - 他のコレクションのスライス**

      * **なぜ学ぶのか:** 配列やベクタなど、他のコレクションの一部分への参照を扱う方法を学ぶため。
      * **何を学ぶのか:** 配列スライス (`&[T]`)。
      * **何をするのか:**
        1.  整数の配列を作成し、その一部分を指すスライスを作成する。
        2.  スライスを引数に取る関数を作成し、配列の一部を処理するコードを書く。
      * **目標レベル:** 4

  * **タスク 19: 構造体 (Structs) - 基本的な定義とインスタンス化**

      * **なぜ学ぶのか:** 関連する複数の値をまとめて一つのデータ型として扱う方法を学ぶため。
      * **何を学ぶのか:** `struct` キーワードによる構造体の定義、フィールドの定義、インスタンスの作成、フィールドへのアクセス。
      * **何をするのか:**
        1.  `User` のような単純な構造体 (例: `username: String`, `active: bool`) を定義する。
        2.  その構造体のインスタンスをいくつか作成し、フィールドの値を設定・表示する。
        3.  フィールド初期化省略記法や構造体更新記法を試す。
      * **目標レベル:** 4

  * **タスク 20: 構造体 (Structs) - メソッド (impl)**

      * **なぜ学ぶのか:** 構造体に関連する振る舞いを定義する方法を学ぶため。
      * **何を学ぶのか:** `impl` ブロック、メソッド定義 (`&self`, `&mut self`, `self`)、関連関数 (associated functions)。
      * **何をするのか:**
        1.  前のタスクで作成した `User` 構造体に、ユーザー情報を表示するメソッドや、アクティブ状態を変更するメソッドを追加する。
        2.  構造体のインスタンスからメソッドを呼び出す。
        3.  `User::new(...)` のようなコンストラクタとして機能する関連関数を定義する。
      * **目標レベル:** 4

  * **タスク 21: 構造体 (Structs) - `#[derive(Debug)]` とデバッグ表示**

      * **なぜ学ぶのか:** 開発中に構造体の内容を簡単に出力してデバッグする方法を学ぶため。
      * **何を学ぶのか:** `Debug` トレイト、`#[derive(Debug)]` アトリビュート、`println!("{:?}", ...)` や `dbg!(...)` マクロ。
      * **何をするのか:**
        1.  作成した構造体に `#[derive(Debug)]` を追加する。
        2.  `println!("{:?}", instance)` や `dbg!(instance)` を使って構造体のインスタンスの内容を表示する。
      * **目標レベル:** 4

  * **タスク 22: 列挙型 (Enums) - 基本的な定義と利用**

      * **なぜ学ぶのか:** ある値がとりうる複数の状態や種類を表現する方法を学ぶため。
      * **何を学ぶのか:** `enum` キーワードによる列挙型の定義、ヴァリアント、インスタンスの作成。
      * **何をするのか:**
        1.  `Message` のような列挙型 (例: `Quit`, `Write(String)`, `Move { x: i32, y: i32 }`) を定義する。
        2.  各ヴァリアントのインスタンスを作成する。
      * **目標レベル:** 4

  * **タスク 23: パターンマッチ (match) - 列挙型との組み合わせ**

      * **なぜ学ぶのか:** 列挙型の各ヴァリアントに応じて異なる処理を実行する、強力で安全な方法を学ぶため。
      * **何を学ぶのか:** `match` 式、網羅性のチェック、`_` (ワイルドカード)。
      * **何をするのか:**
        1.  前のタスクで定義した `Message` 列挙型の値に対して `match` 式を使い、ヴァリアントごとに異なるメッセージを表示する関数を書く。
        2.  `match` が網羅的であることを確認する（全てのヴァリアントを処理しないとコンパイルエラー）。
      * **目標レベル:** 4

  * **タスク 24: `Option<T>` 列挙型と `match`**

      * **なぜ学ぶのか:** 値が存在しない可能性を明示的に扱うための標準的な方法を学ぶため。Null参照エラーを防ぐ。
      * **何を学ぶのか:** `Option<T>` (`Some(T)` と `None`)、`match` を使った `Option` の処理。
      * **何をするのか:**
        1.  数値の除算を行う関数を書き、ゼロ除算の場合に `None` を、それ以外の場合に `Some(result)` を返すようにする。
        2.  返ってきた `Option` を `match` で処理し、結果を表示するかエラーメッセージを表示する。
      * **目標レベル:** 4

  * **タスク 25: `if let` と `while let` による簡潔なマッチ**

      * **なぜ学ぶのか:** `match` が冗長になる特定の場合（一つのパターンのみに関心がある場合）に、より簡潔に書く方法を学ぶため。
      * **何を学ぶのか:** `if let` 構文、`while let` 構文。
      * **何をするのか:**
        1.  `Option<i32>` 型の値があり、`Some` の場合のみ中の値を使って処理をしたい場合に `if let` を使って書く。
        2.  `Vec::pop()` (ベクタから末尾の要素を取り出す、`Option` を返す) と `while let` を組み合わせて、ベクタの要素がなくなるまで処理するコードを書く。
      * **目標レベル:** 4

  * **タスク 26: モジュール (mod) - 基本的なファイル分割**

      * **なぜ学ぶのか:** プロジェクトが大きくなってきたときに、コードを整理し、名前空間を分割する方法を学ぶため。
      * **何を学ぶのか:** `mod` キーワード、別ファイルへのモジュールの切り出し、`main.rs` や `lib.rs` からの参照。
      * **何をするのか:**
        1.  簡単な関数群を別のファイル (例: `my_module.rs`) に記述し、`main.rs` から `mod my_module;` で宣言して中の関数を呼び出す。
        2.  （まだ `pub` は使わず、同一モジュール内からのアクセスを試す）
      * **目標レベル:** 4

  * **タスク 27: `Result<T, E>` とエラーハンドリング入門**

      * **なぜ学ぶのか:** 回復可能なエラーを表現し、処理するための標準的な方法を学ぶため。
      * **何を学ぶのか:** `Result<T, E>` (`Ok(T)` と `Err(E)`)、`match` を使った `Result` の処理。
      * **何をするのか:**
        1.  ファイルを開こうとする簡単な処理を（まだ実際のファイルI/Oクレートは使わず、関数の戻り値として）`Result<String, String>` (成功時は"ファイル内容"、失敗時は"エラー理由"の文字列) を返すように模擬的に書く。
        2.  返ってきた `Result` を `match` で処理し、成功時と失敗時で異なるメッセージを表示する。
      * **目標レベル:** 4

  * **タスク 28: `?` 演算子によるエラーの伝播**

      * **なぜ学ぶのか:** `Result` を返す関数が連鎖する場合に、エラー処理を簡潔に書く方法を学ぶため。
      * **何を学ぶのか:** `?` 演算子の使い方、`Result` を返す関数内でのみ使用可能であること。
      * **何をするのか:**
        1.  前のタスクの模擬ファイル読み込み関数を呼び出し、その結果が `Err` なら早期リターンするような別の関数を `match` を使って書く。
        2.  同じ処理を `?` 演算子を使って書き換えてみる。
      * **目標レベル:** 4

  * **タスク 29: ベクタ (`Vec<T>`) の基本**

      * **なぜ学ぶのか:** 可変長のリスト（配列）を扱うための最も一般的なコレクションを学ぶため。
      * **何を学ぶのか:** `Vec::new()`、`push`, `pop`, インデックスアクセス、イテレーション。
      * **何をするのか:**
        1.  整数のベクタを作成し、いくつかの要素を追加する。
        2.  特定の位置の要素にアクセスして表示する（範囲外アクセス時の `panic!` も試す）。
        3.  `for` ループを使ってベクタの全要素をイテレートし、表示する。
      * **目標レベル:** 4

  * **タスク 30: 文字列 (`String`) の操作**

      * **なぜ学ぶのか:** 可変長のUTF-8エンコードされた文字列を扱う方法を学ぶため。
      * **何を学ぶのか:** `String::new()`, `String::from()`, `push_str`, `+` (結合)、`format!` マクロ。
      * **何をするのか:**
        1.  `String` を作成し、文字列を追加したり結合したりする。
        2.  `format!` マクロを使って整形された文字列を作成する。
        3.  `String` と `&str` の関係を再確認する。
      * **目標レベル:** 4

  * **タスク 31: ハッシュマップ (`HashMap<K, V>`) の基本**

      * **なぜ学ぶのか:** キーと値のペアを格納するコレクションを学ぶため。Python の辞書に相当。
      * **何を学ぶのか:** `HashMap::new()`, `insert`, `get`, イテレーション。
      * **何をするのか:**
        1.  文字列をキー、整数を値とするハッシュマップを作成し、いくつかのエントリを挿入する。
        2.  キーを使って値を取得する（`get` は `Option` を返すことに注意）。
        3.  `for` ループを使ってハッシュマップの全キーと値をイテレートし、表示する。
      * **目標レベル:** 4

  * **タスク 32: `Cargo.toml` と依存クレートの追加 (簡単なもの)**

      * **なぜ学ぶのか:** 外部のライブラリ (クレート) をプロジェクトに追加して利用する方法を学ぶため。
      * **何を学ぶのか:** `Cargo.toml` ファイルの `[dependencies]` セクション、`crates.io` からクレートを探す方法 (例: `rand` クレート)。
      * **何をするのか:**
        1.  `crates.io` で `rand` クレートを検索する。
        2.  `Cargo.toml` に `rand = "0.8"` (バージョンは適宜最新に) のように依存関係を追加する。
        3.  `main.rs` で `use rand::Rng;` し、乱数を生成して表示する簡単なコードを書く。`cargo build` や `cargo run` でクレートがダウンロード・コンパイルされることを確認する。
      * **目標レベル:** 4

  * **タスク 33: Rust 公式ドキュメントの歩き方**

      * **なぜ学ぶのか:** 学習や開発中に必要な情報を効率的に見つけるための情報源を知るため。
      * **何を学ぶのか:** "The Rust Programming Language" (The Book)、"Rust by Example"、標準ライブラリドキュメントの構成と検索方法。
      * **何をするのか:**
        1.  The Book ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)) の目次を見て、これまでに学んだ章を軽く読み返す。
        2.  標準ライブラリドキュメントで `Vec` や `String` のページを探し、利用可能なメソッド一覧を眺める。
      * **目標レベル:** 4

  * **タスク 34: 基本的なユニットテスト (`#[test]`)**

      * **なぜ学ぶのか:** コードの正しさを自動的に検証する方法を学び、リファクタリングや機能追加を安全に行えるようにするため。
      * **何を学ぶのか:** `#[test]` アトリビュート、テスト関数の書き方、`assert!` マクロ、`assert_eq!` マクロ、`cargo test` コマンド。
      * **何をするのか:**
        1.  これまでに作成した簡単な関数 (例: 数値を足す関数) に対するテスト関数を `src/main.rs` (または `src/lib.rs`) の末尾に書く。
        2.  `cargo test` を実行してテストが成功することを確認する。
        3.  わざと失敗するテストを書いて、エラーメッセージを確認する。
      * **目標レベル:** 4

  * **フェーズ2 確認テストのテーマ:**

      * 所有権、ムーブ、クローンの違いをコード例とともに説明。
      * 不変参照と可変参照のルール、ダングリング参照がなぜ発生しないかの説明。
      * 文字列スライス (`&str`) と `String` の使い分け。
      * 構造体と列挙型を定義し、メソッドや `match` 式と組み合わせて使用するコードの作成。
      * `Option<T>` と `Result<T, E>` を使ったエラー処理と、`?` 演算子の役割の説明。
      * `Vec`, `String`, `HashMap` の基本的な操作。
      * 簡単なユニットテストの作成。
      * Git でここまでの変更をコミットする。

-----

#### フェーズ3: ライフタイム・ジェネリクス・トレイトによる抽象化 (目標: レベル5)

  * **タスク 35: ライフタイム (Lifetimes) - 基本的な必要性**

      * **なぜ学ぶのか:** コンパイラが参照の有効性を保証できない曖昧な状況を解決し、ダングリング参照を確実に防ぐため。
      * **何を学ぶのか:** ライフタイム注釈 (`'a`) の基本的な考え方、関数シグネチャにおけるライフタイム指定の必要性。
      * **何をするのか:**
        1.  2つの文字列スライスのうち長い方を返す関数を考え、ライフタイム注釈なしではコンパイルエラーになる例を作成する。
        2.  エラーメッセージを読み、なぜライフタイムが必要なのかを理解する。
      * **目標レベル:** 5

  * **タスク 36: ライフタイム (Lifetimes) - 関数シグネチャへの明示的な指定**

      * **なぜ学ぶのか:** 複数の参照を入力とし、参照を出力する関数で、出力される参照がどの入力参照のライフタイムに依存するかをコンパイラに伝えるため。
      * **何を学ぶのか:** 関数シグネチャへのライフタイムパラメータ (`<'a>`) とライフタイム注釈 (`&'a str`) の書き方。
      * **何をするのか:**
        1.  前のタスクの「長い方の文字列スライスを返す関数」に適切なライフタイム注釈を付与し、コンパイルできるようにする。
        2.  ライフタイムの異なる参照を渡した場合の動作を確認する。
      * **目標レベル:** 5

  * **タスク 37: ライフタイム (Lifetimes) - 構造体定義におけるライフタイム**

      * **なぜ学ぶのか:** 構造体が参照を保持する場合、その参照が構造体インスタンス自身よりも長く生存することを保証するため。
      * **何を学ぶのか:** 構造体定義へのライフタイムパラメータ (`struct Foo<'a>`)、フィールドの参照型へのライフタイム注釈 (`data: &'a str`)。
      * **何をするのか:**
        1.  文字列スライスをフィールドとして持つ構造体 `ImportantExcerpt<'a>` を定義する。
        2.  そのインスタンスを作成し、ライフタイムがどのように機能するかを確認する（例えば、参照元のデータが先にスコープを抜けるとコンパイルエラー）。
      * **目標レベル:** 5

  * **タスク 38: ライフタイム (Lifetimes) - ライフタイム省略規則 (Elision Rules)**

      * **なぜ学ぶのか:** よくあるパターンではライフタイム注釈を省略できることを知り、コードを簡潔に保つため。ただし、省略規則を理解することで、なぜコンパイラがライフタイムを推論できるのかが分かる。
      * **何を学ぶのか:** 3つの主要なライフタイム省略規則。
      * **何をするのか:**
        1.  The Book のライフタイム省略規則の章を読む。
        2.  これまでに書いたライフタイム注釈付きの関数で、省略可能なケースがないか確認する。
      * **目標レベル:** 5

  * **タスク 39: ライフタイム (Lifetimes) - 静的ライフタイム (`'static`)**

      * **なぜ学ぶのか:** プログラムの実行期間全体を通じて有効な参照を表す方法を学ぶため。
      * **何を学ぶのか:** `'static` ライフタイムの意味、文字列リテラルが `'static` であること。
      * **何をするのか:**
        1.  文字列リテラルを変数に束縛し、それが `'static` ライフタイムを持つことを理解する。
        2.  `'static` を要求する関数や型 (例: スレッド間でデータを共有する際の制約として現れることがある) の例を見る。
      * **目標レベル:** 5

  * **タスク 40: ジェネリクス (Generics) - 関数定義での利用**

      * **なぜ学ぶのか:** 異なる型に対して同じロジックのコードを再利用可能にするため。
      * **何を学ぶのか:** 型パラメータ (`<T>`) を使った関数定義、具体的な型での呼び出し。
      * **何をするのか:**
        1.  任意の型の値を一つ受け取り、それをそのまま返す `identity` 関数をジェネリクスを使って定義する。
        2.  整数、浮動小数点数、文字列など、異なる型でこの関数を呼び出してみる。
        3.  2つの値を取り、大きい方を返すジェネリック関数を (まだトレイト境界なしで) 書こうとしてみて、問題点に気づく (比較ができない)。
      * **目標レベル:** 5

  * **タスク 41: ジェネリクス (Generics) - 構造体定義での利用**

      * **なぜ学ぶのか:** 様々な型の値を保持できる構造体を定義するため。
      * **何を学ぶのか:** 型パラメータを使った構造体定義。
      * **何をするのか:**
        1.  `Point<T>` のように、x座標とy座標が同じ任意の型 `T` である構造体を定義する。
        2.  `Point<i32>` や `Point<f64>` のインスタンスを作成する。
        3.  `Point<T, U>` のように複数の型パラメータを持つ構造体も試す。
      * **目標レベル:** 5

  * **タスク 42: ジェネリクス (Generics) - `impl` ブロックでの利用**

      * **なぜ学ぶのか:** ジェネリックな構造体や列挙型にメソッドを実装するため。
      * **何を学ぶのか:** `impl<T>` ブロック、特定の型パラメータに対するメソッド実装 (`impl Point<f32>`)。
      * **何をするのか:**
        1.  前のタスクで定義した `Point<T>` 構造体に、x座標を返すメソッド `x(&self) -> &T` を実装する。
        2.  `Point<f32>` の場合にのみ利用可能なメソッド (例: 原点からの距離を計算するメソッド) を実装してみる。
      * **目標レベル:** 5

  * **タスク 43: トレイト (Traits) - 共通の振る舞いを定義する**

      * **なぜ学ぶのか:** 異なる型が共通して持つべき振る舞い（インターフェース）を定義し、アドホック多相を実現するため。
      * **何を学ぶのか:** `trait` キーワード、メソッドシグネチャの定義。
      * **何をするのか:**
        1.  `Summarizable` のようなトレイトを定義し、`summarize(&self) -> String` というメソッドシグネチャを持たせる。
      * **目標レベル:** 5

  * **タスク 44: トレイト (Traits) - 型への実装 (`impl Trait for Type`)**

      * **なぜ学ぶのか:** 具体的な型にトレイトで定義された振る舞いを実装するため。
      * **何を学ぶのか:** `impl MyTrait for MyType` 構文、トレイトメソッドの実装。
      * **何をするのか:**
        1.  `NewsArticle` 構造体と `Tweet` 構造体を定義する。
        2.  これらの構造体に、前のタスクで定義した `Summarizable` トレイトを実装し、それぞれ異なる要約文字列を返すようにする。
      * **目標レベル:** 5

  * **タスク 45: トレイト (Traits) - トレイトを引数として受け取る関数**

      * **なぜ学ぶのか:** 特定の振る舞いを持つ任意の型を受け入れる関数を書くため。
      * **何を学ぶのか:** `impl Trait` 構文 (引数位置)、トレイト境界 (`<T: MyTrait>`)。
      * **何をするのか:**
        1.  `Summarizable` トレイトを実装した任意の型の値を受け取り、その `summarize` メソッドを呼び出して結果を表示する関数 `notify(item: &impl Summarizable)` を書く。
        2.  同じ関数をトレイト境界を使って `notify_generic<T: Summarizable>(item: &T)` としても書けることを確認する。
      * **目標レベル:** 5

  * **タスク 46: トレイト境界 (Trait Bounds) の応用**

      * **なぜ学ぶのか:** ジェネリック型パラメータが特定のトレイトを実装していることを要求し、ジェネリックコード内でそのトレイトのメソッドを使えるようにするため。
      * **何を学ぶのか:** `where`句を使った複雑なトレイト境界、複数のトレイト境界 (`T: Display + Clone`)。
      * **何をするのか:**
        1.  タスク40で試した「大きい方を返すジェネリック関数」に `std::cmp::PartialOrd` トレイト境界を追加し、比較可能にする。
        2.  `Display` トレイトと `Debug` トレイトの両方を実装する型のみを受け付けるジェネリック関数を書いてみる。
      * **目標レベル:** 5

  * **タスク 47: トレイト (Traits) - `derive` できる標準トレイト**

      * **なぜ学ぶのか:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` などのよく使われる振る舞いを簡単に型に追加するため。
      * **何を学ぶのか:** `#[derive(...)]` アトリビュートで利用可能な標準トレイトとその意味。
      * **何をするのか:**
        1.  自作の構造体にこれらの標準トレイトを `derive` してみて、どのような機能が追加されるか確認する (例: `PartialEq` を derive すると `==` で比較可能になる)。
      * **目標レベル:** 5

  * **タスク 48: イテレータ (Iterators) - 基本と `for` ループ**

      * **なぜ学ぶのか:** コレクションの要素を順番に処理するための強力で効率的な抽象化を学ぶため。Python のイテレータと似ているが、Rust ではより中心的な役割を果たす。
      * **何を学ぶのか:** `Iterator` トレイト、`iter()` メソッド、`next()` メソッド、`for` ループが内部でイテレータを使っていること。
      * **何をするのか:**
        1.  ベクタの `iter()` メソッドを呼び出してイテレータを取得し、手動で `next()` を呼び出して要素を取り出す。
        2.  `for item in my_vector.iter()` がどのように動作するかを理解する。
      * **目標レベル:** 5

  * **タスク 49: イテレータ (Iterators) - アダプタ (`map`, `filter`)**

      * **なぜ学ぶのか:** イテレータを変換したりフィルタリングしたりして、新しいイテレータを生成する宣言的な方法を学ぶため。コードを簡潔にし、パフォーマンスも良いことが多い。
      * **何を学ぶのか:** `map` アダプタ、`filter` アダプタ、クロージャとの組み合わせ。
      * **何をするのか:**
        1.  数値のベクタがあり、各要素を2倍した新しいベクタを `map` を使って作成する (まだ `collect` はしない)。
        2.  数値のベクタから、偶数のみをフィルタリングするイテレータを `filter` を使って作成する。
      * **目標レベル:** 5

  * **タスク 50: イテレータ (Iterators) - 消費アダプタ (`collect`, `sum`, `count`)**

      * **なぜ学ぶのか:** イテレータから値を取り出してコレクションに集めたり、集計したりする方法を学ぶため。
      * **何を学ぶのか:** `collect()` メソッド (型注釈が必要な場合がある)、`sum()`、`count()` など。
      * **何をするのか:**
        1.  前のタスクで `map` や `filter` を使って作成したイテレータから、`collect()` を使って新しい `Vec` を作成する。
        2.  数値のベクタの合計を `sum()` で計算する。
      * **目標レベル:** 5

  * **タスク 51: クロージャ (Closures) - 基本的な構文とキャプチャ**

      * **なぜ学ぶのか:** 関数のように呼び出せる軽量な匿名関数オブジェクトを作成し、イテレータアダプタなどで柔軟に処理を記述するため。
      * **何を学ぶのか:** クロージャの構文 (`|arg| body`)、環境からの変数のキャプチャ（ムーブ、不変借用、可変借用）。
      * **何をするのか:**
        1.  簡単な加算を行うクロージャを作成し、呼び出す。
        2.  クロージャが定義されたスコープの変数をキャプチャして利用する例を書く。
        3.  `move` クロージャを試す。
      * **目標レベル:** 5

  * **タスク 52: スマートポインタ - `Box<T>`**

      * **なぜ学ぶのか:** ヒープにデータを割り当て、所有権を持つポインタを扱う方法を学ぶため。再帰的なデータ構造などで必要。
      * **何を学ぶのか:** `Box::new()`、間接参照。
      * **何をするのか:**
        1.  単純な値を `Box` を使ってヒープに割り当てる。
        2.  再帰的な型 (例: `List = Cons(i32, Box<List>)`) を `Box` を使って定義する簡単な例を見る。
      * **目標レベル:** 5 (ここでは概要の理解)

  * **タスク 53: 高度なエラーハンドリング - `thiserror` クレート**

      * **なぜ学ぶのか:** ライブラリを作成する際に、構造化されたカスタムエラー型を簡単に定義するため。
      * **何を学ぶのか:** `thiserror` の基本的な使い方 (`#[error(...)]` アトリビュート)。
      * **何をするのか:**
        1.  `crates.io` で `thiserror` を探し、`Cargo.toml` に追加。
        2.  いくつかのエラーヴァリアントを持つカスタムエラー列挙型を `thiserror` を使って定義してみる。
      * **目標レベル:** 5

  * **タスク 54: 高度なエラーハンドリング - `anyhow` クレート**

      * **なぜ学ぶのか:** アプリケーションを作成する際に、様々な種類のエラーを統一的に扱いやすくするため。
      * **何を学ぶのか:** `anyhow::Result<T>`、`anyhow::Error`、`context` メソッド。
      * **何をするのか:**
        1.  `crates.io` で `anyhow` を探し、`Cargo.toml` に追加。
        2.  複数の異なるエラー型を返す可能性のある関数を `anyhow::Result` を使ってラップし、`context` でエラー情報を追加する例を書く。
      * **目標レベル:** 5

  * **タスク 55: ドキュメントコメントと `cargo doc`**

      * **なぜ学ぶのか:** ライブラリやアプリケーションのAPIドキュメントを生成し、他の開発者や将来の自分がコードを理解しやすくするため。
      * **何を学ぶのか:** `///` (アイテム用)、`//!` (モジュール用) ドキュメントコメント、Markdown の利用、コード例の埋め込み、`cargo doc --open`。
      * **何をするのか:**
        1.  これまでに作成した公開関数や構造体にドキュメントコメントを記述する。
        2.  簡単なコード例をドキュメントコメント内に含める。
        3.  `cargo doc --open` を実行し、生成されたHTMLドキュメントを確認する。
      * **目標レベル:** 5

  * **タスク 56: `cargo fmt` と `cargo clippy` の活用**

      * **なぜ学ぶのか:** Rust の標準的なコードフォーマットを適用し、潜在的なバグや非効率なコードを静的解析で見つけることで、「Rustらしい」コードを書く習慣を身につけるため。
      * **何を学ぶのか:** `cargo fmt` コマンド、`cargo clippy` コマンド。
      * **何をするのか:**
        1.  これまでのプロジェクトで `cargo fmt` を実行し、コードが整形されるのを確認する。
        2.  `cargo clippy` を実行し、提案される警告や改善点があれば修正を試みる。
      * **目標レベル:** 5

  * **フェーズ3 確認テストのテーマ:**

      * ライフタイムが必要になる典型的なケースと、関数や構造体へのライフタイム注釈の記述方法。
      * ジェネリクスを使って型安全で再利用可能な関数や構造体を定義する方法。
      * トレイトを定義し、複数の型に実装して共通の振る舞いを実現する方法、トレイト境界の使い方。
      * イテレータの基本的な使い方と、`map`, `filter`, `collect` などのアダプタの利用。
      * クロージャの構文と、環境変数をキャプチャする仕組み。
      * `thiserror` または `anyhow` を使ったエラー処理の改善。
      * ドキュメントコメントの書き方と `cargo doc` の利用。
      * Git でここまでの変更をコミットする。

-----

#### フェーズ4: クレート活用とプロジェクト構成 (目標: レベル6)

  * **タスク 57: モジュールシステム詳解 - 可視性 (`pub`)**

      * **なぜ学ぶのか:** モジュール内のアイテム（関数、構造体など）をモジュールの外からアクセス可能にする方法を制御するため。ライブラリのAPI設計に不可欠。
      * **何を学ぶのか:** `pub` キーワード、`pub(crate)`, `pub(super)`, `pub(in path)`。
      * **何をするのか:**
        1.  複数のモジュールを持つ小さなプロジェクトを作成する。
        2.  `pub` を使って一部の関数や構造体を外部モジュールに公開し、他は非公開のままにする。
        3.  `pub(crate)` などを使って、より細かい可視性の制御を試す。
      * **目標レベル:** 6

  * **タスク 58: モジュールシステム詳解 - `use` 宣言**

      * **なぜ学ぶのか:** 他のモジュールのアイテムを現在のスコープに持ち込み、短い名前でアクセスできるようにするため。
      * **何を学ぶのか:** `use` キーワード、`as` での別名、`self` と `super`、glob (`*`)。
      * **何をするのか:**
        1.  前のタスクのプロジェクトで、`use` を使って他のモジュールの公開アイテムをスコープに導入する。
        2.  `use` でパスを短縮したり、`as` で別名をつけたりする。
      * **目標レベル:** 6

  * **タスク 59: ライブラリクレート (`lib.rs`) とバイナリクレート (`main.rs`)**

      * **なぜ学ぶのか:** 再利用可能なライブラリと、それを実行するアプリケーションを分離して開発する方法を学ぶため。
      * **何を学ぶのか:** `cargo new my_project` (バイナリ) と `cargo new --lib my_library` (ライブラリ) の違い、`src/main.rs` と `src/lib.rs` の役割。
      * **何をするのか:**
        1.  簡単な計算機能を持つライブラリクレートを作成する (`src/lib.rs` に `pub fn add(...)` など)。
        2.  同じワークスペース（後述）または別の場所でバイナリクレートを作成し、`Cargo.toml` でライブラリクレートを依存関係として追加（`path = "../my_library"`など）して利用する。
      * **目標レベル:** 6

  * **タスク 60: クレートエコシステム - `serde` によるシリアライズ**

      * **なぜ学ぶのか:** Rust のデータ構造を JSON や他のフォーマットに変換 (シリアライズ) し、ファイル保存やネットワーク送信ができるようにするため。非常に広く使われるクレート。
      * **何を学ぶのか:** `serde` と `serde_json` クレート、`Serialize` トレイト、`#[derive(Serialize)]`、`serde_json::to_string()`。
      * **何をするのか:**
        1.  `serde` と `serde_json` を `Cargo.toml` に追加。
        2.  簡単な構造体を定義し、`#[derive(Serialize)]` を付与する。
        3.  その構造体のインスタンスを `serde_json::to_string()` または `serde_json::to_string_pretty()` でJSON文字列に変換し、表示する。
      * **目標レベル:** 6

  * **タスク 61: クレートエコシステム - `serde` によるデシリアライズ**

      * **なぜ学ぶのか:** JSON や他のフォーマットのデータから Rust のデータ構造を復元 (デシリアライズ) するため。
      * **何を学ぶのか:** `Deserialize` トレイト、`#[derive(Deserialize)]`、`serde_json::from_str()`。
      * **何をするのか:**
        1.  前のタスクで定義した構造体に `#[derive(Deserialize)]` を追加 (または新規に定義)。
        2.  JSON文字列 (手動で作成または前のタスクで生成したもの) を `serde_json::from_str()` で構造体のインスタンスにデシリアライズし、フィールドの値を表示する。
      * **目標レベル:** 6

  * **タスク 62: クレートエコシステム - `reqwest` によるHTTP GETリクエスト**

      * **なぜ学ぶのか:** Web API からデータを取得するなど、HTTPリクエストを簡単に行う方法を学ぶため。CLIツールやAIアプリで頻用。
      * **何を学ぶのか:** `reqwest` クレート (非同期がメインだが、同期クライアント `blocking` もある)、基本的なGETリクエストの送信、レスポンスの処理。
      * **何をするのか:**
        1.  `reqwest` (と `tokio` が必要になる場合もあるので `features = ["blocking", "json"]` などを指定) を `Cargo.toml` に追加。
        2.  公開されている JSON API (例: [https://jsonplaceholder.typicode.com/todos/1](https://www.google.com/search?q=https://jsonplaceholder.typicode.com/todos/1)) に対して `reqwest::blocking::get()` でGETリクエストを送信する。
        3.  レスポンスボディをテキストとして取得し表示する。可能ならJSONとしてパース (`.json::<serde_json::Value>()` または具体的な型) して一部のデータを表示する。
      * **目標レベル:** 6

  * **タスク 63: 簡単な CLI ツール作成 (アイデア1: TODO リスト管理)**

      * **なぜ学ぶのか:** これまでに学んだ知識 (構造体、ベクタ、ファイルI/O、`serde`、コマンドライン引数処理) を統合し、実用的な小さなアプリケーションを作成する経験を得るため。
      * **何を学ぶのか:** 簡単なコマンドライン引数の解釈 (標準ライブラリの `std::env::args()` または `clap` クレートの初歩)。ファイルへの保存・読み込み。
      * **何をするのか:**
        1.  タスクの追加 (`add "task description"`)、一覧表示 (`list`)、完了 (`complete <task_id>`) ができるシンプルなTODOリストCLIを構想する。
        2.  タスクを格納する構造体 (例: `id`, `description`, `completed`) を定義する。
        3.  タスクリストを `Vec<Task>` でメモリ上に保持し、コマンドに応じて操作するロジックを書く。
        4.  (次のタスクでファイル永続化)
      * **目標レベル:** 6

  * **タスク 64: CLI ツール作成 (アイデア1続き: ファイル永続化)**

      * **なぜ学ぶのか:** アプリケーションの状態をファイルに保存し、次回起動時にも利用できるようにするため。
      * **何を学ぶのか:** `std::fs::File` によるファイルの読み書き、`serde_json` を使った `Vec<Task>` のシリアライズ/デシリアライズ。
      * **何をするのか:**
        1.  TODOリストの状態 (タスクのベクタ) をJSON形式でファイル (例: `todos.json`) に保存する関数を書く。
        2.  アプリケーション起動時にファイルからTODOリストを読み込む関数を書く。
        3.  タスク追加・完了時にファイルに保存する処理を組み込む。
      * **目標レベル:** 6

  * **タスク 65: クレートエコシステム - `clap` によるコマンドライン引数解析**

      * **なぜ学ぶのか:** 複雑なコマンドライン引数、サブコマンド、オプション、ヘルプメッセージなどを簡単に扱える強力なクレートを学ぶため。
      * **何を学ぶのか:** `clap` クレートの基本的な使い方 (derive API または builder API)。
      * **何をするのか:**
        1.  `clap` を `Cargo.toml` に追加。
        2.  前のタスクのTODOリストCLIの引数処理を `clap` を使って書き換える。
        3.  サブコマンド (`add`, `list`, `complete`) を定義し、引数をパースできるようにする。ヘルプメッセージが自動生成されることを確認する。
      * **目標レベル:** 6

  * **タスク 66: トレイトオブジェクト (`Box<dyn Trait>`)**

      * **なぜ学ぶのか:** 実行時に型が異なるが同じトレイトを実装するオブジェクトのコレクションを扱うなど、動的ディスパッチを実現するため。
      * **何を学ぶのか:** `dyn Trait` 構文、トレイトオブジェクトはサイズ不定のため `Box` などでヒープに置く必要があること。
      * **何をするのか:**
        1.  複数の異なる図形 (例: `Circle`, `Rectangle`) 構造体を定義し、それぞれ `Drawable` トレイト (例: `draw(&self)` メソッドを持つ) を実装する。
        2.  `Vec<Box<dyn Drawable>>` を作成し、異なる図形のインスタンスを格納し、ループで各図形の `draw` メソッドを呼び出す。
      * **目標レベル:** 6

  * **タスク 67: `Result<T, E>` の `map`, `and_then` など**

      * **なぜ学ぶのか:** `Result` 型の値をより関数型プログラミングスタイルで簡潔に処理する方法を学ぶため。
      * **何を学ぶのか:** `map()`, `map_err()`, `and_then()`, `or_else()` などのメソッド。
      * **何をするのか:**
        1.  `Result<String, _>` を返し、成功時に文字列の長さを計算する処理を `map` を使って書く。
        2.  複数の `Result` を返す処理を連鎖させる場合に `and_then` を使ってみる。
      * **目標レベル:** 6

  * **タスク 68: マクロ (`macro_rules!`) の基礎 - 簡単な繰り返しコードの削減**

      * **なぜ学ぶのか:** コード生成によって定型的な繰り返しコードを減らし、より宣言的なAPIを作成するための第一歩。
      * **何を学ぶのか:** `macro_rules!` の基本的な構文、マッチャー、トランスフォーマー。
      * **何をするのか:**
        1.  非常に簡単なマクロ、例えばベクタを簡単に初期化する `my_vec![1, 2, 3]` のようなマクロを定義してみる。
        2.  The Book のマクロの章を読み始める。
      * **目標レベル:** 6

  * **タスク 69: テストのモジュール化とインテグレーションテスト**

      * **なぜ学ぶのか:** テストコードを整理し、ライブラリの公開APIを外部からテストする方法を学ぶため。
      * **何を学ぶのか:** `tests` ディレクトリ、`#[cfg(test)]` と `mod tests { ... }`。
      * **何をするのか:**
        1.  ライブラリクレートのプロジェクトで、`src/lib.rs` 内に `#[cfg(test)] mod tests { ... }` を作成し、ユニットテストをそこに移動する。
        2.  プロジェクトルートに `tests` ディレクトリを作成し、その中にインテグレーションテストファイル (例: `integration_test.rs`) を作成して、ライブラリの公開関数をテストする。
      * **目標レベル:** 6

  * **フェーズ4 確認テストのテーマ:**

      * モジュールシステム (`mod`, `pub`, `use`) を使ったコードの構成方法。
      * ライブラリクレートとバイナリクレートの違い、それらの連携方法。
      * `serde` を使ったデータ構造のJSONへのシリアライズ・デシリアライズ。
      * `reqwest` (blocking) を使った簡単なHTTPリクエストの送信とレスポンス処理。
      * `clap` を使ったコマンドライン引数の解析。
      * トレイトオブジェクト (`Box<dyn Trait>`) のユースケースと基本的な使い方。
      * `macro_rules!` を使った簡単なマクロの定義と使用。
      * Git でここまでの変更をコミットする。

-----

#### フェーズ5: 非同期プログラミングと高度なトピック入門 (目標: レベル7)

  * **タスク 70: 非同期プログラミング (Async/Await) - 基本概念**

      * **なぜ学ぶのか:** I/Oバウンドな処理 (ファイルアクセス、ネットワーク通信など) を効率的に行い、多数の処理を同時に捌けるようにするため。GUIアプリやAIエージェントでも重要。
      * **何を学ぶのか:** 同期処理と非同期処理の違い、ブロッキングとノンブロッキング、`async fn`、`.await`。
      * **何をするのか:**
        1.  The Rust Programming Language (The Book) の非同期プログラミングの章を読む。
        2.  `async fn` で非同期関数を定義し、`.await` でその完了を待つという基本的な構文を理解する。
      * **目標レベル:** 7

  * **タスク 71: 非同期ランタイム - `tokio` の導入と簡単な `async main`**

      * **なぜ学ぶのか:** `async/await` で書かれたコードを実行するための環境 (ランタイム) が必要であり、`tokio` はその代表的なものの一つであるため。
      * **何を学ぶのか:** `tokio` クレート、`#[tokio::main]` アトリビュート。
      * **何をするのか:**
        1.  `tokio` (features = ["macros", "rt-multi-thread"] など) を `Cargo.toml` に追加。
        2.  `main` 関数に `#[tokio::main]` アトリビュートをつけ、`async fn main()` とし、その中で簡単な非同期処理 (例: `tokio::time::sleep`) を `.await` するコードを書く。
      * **目標レベル:** 7

  * **タスク 72: `reqwest` の非同期クライアント**

      * **なぜ学ぶのか:** `reqwest` の主要な機能である非同期HTTPリクエストを `async/await` と組み合わせて使うため。
      * **何を学ぶのか:** `reqwest` の非同期API (blocking ではない通常の `reqwest::get` など)。
      * **何をするのか:**
        1.  `reqwest` (tokio feature が有効になっていることを確認) を使う。
        2.  `async fn` 内で `reqwest::get(...).await?` を使って非同期にHTTP GETリクエストを送信し、レスポンスを処理する。
        3.  (例: 複数のURLに同時にリクエストを投げるのは次の `join` や `FuturesUnordered` で)
      * **目標レベル:** 7

  * **タスク 73: `futures` クレート - `join!` マクロ**

      * **なぜ学ぶのか:** 複数の `Future` を同時に実行し、全てが完了するのを待つ方法を学ぶため。
      * **何を学ぶのか:** `futures::join!` マクロ。
      * **何をするのか:**
        1.  `futures` クレートを `Cargo.toml` に追加。
        2.  2つの異なる `tokio::time::sleep` や、2つの異なる `reqwest::get` 呼び出し (Futureを返す) を `join!` を使って並行に実行し、両方の結果を取得するコードを書く。
      * **目標レベル:** 7

  * **タスク 74: `futures` クレート - `Stream` トレイトの概要**

      * **なぜ学ぶのか:** 非同期的に連続して値を生成するシーケンス (非同期版イテレータ) の概念を理解するため。
      * **何を学ぶのか:** `Stream` トレイトの概念、`StreamExt` のヘルパーメソッド (例: `next()`, `collect()`)。
      * **何をするのか:**
        1.  `futures` のドキュメントで `Stream` について読む。
        2.  簡単なストリームを作成 (例: `futures::stream::iter`) し、`while let Some(item) = stream.next().await` のように値を非同期に処理する。
      * **目標レベル:** 7

  * **タスク 75: `tokio::spawn` によるタスクの並行実行**

      * **なぜ学ぶのか:** 独立した非同期処理の単位（タスク）を生成し、ランタイムにバックグラウンドで実行させる方法を学ぶため。
      * **何を学ぶのか:** `tokio::spawn()`、`JoinHandle`。
      * **何をするのか:**
        1.  `tokio::spawn` を使って、いくつかの独立した非同期処理 (例: それぞれが少しスリープしてメッセージを表示する) を起動する。
        2.  `JoinHandle` を使ってタスクの完了を待つ (または待たない) ことを試す。
      * **目標レベル:** 7

  * **タスク 76: ワークスペース (Workspace) による複数クレート管理**

      * **なぜ学ぶのか:** 複数の関連するクレート (例: ライブラリとそれを使うバイナリ、または複数のライブラリ) を一つのプロジェクトとしてまとめて管理し、ビルドやテストを効率化するため。
      * **何を学ぶのか:** ルートの `Cargo.toml` の `[workspace]` セクション、`members` 配列。
      * **何をするのか:**
        1.  新しいディレクトリを作成し、その直下に `Cargo.toml` を作成して `[workspace]` を設定。
        2.  その下に複数のクレート (例: `cargo new my_lib --lib` と `cargo new my_app`) を作成し、ルートの `Cargo.toml` の `members` に追加する。
        3.  ルートディレクトリから `cargo build` や `cargo test` を実行すると、全メンバークレートが処理されることを確認する。
        4.  クレート間で依存関係 (`path = "../my_lib"`) を設定する。
      * **目標レベル:** 7

  * **タスク 77: Rustにおけるデザインパターン (Builder パターンの例)**

      * **なぜ学ぶのか:** 一般的なソフトウェア設計パターンを Rust の特徴 (所有権、型システム) を活かしてどのように実装できるかを学ぶため。
      * **何を学ぶのか:** Builder パターンの目的と Rust での実装例。メソッドチェーン。
      * **何をするのか:**
        1.  複雑なオブジェクト (例: 多くのオプションフィールドを持つ `Configuration`) を構築するための Builder 構造体とメソッドを実装する。
        2.  `Configuration::builder().field1(...).field2(...).build()` のように使えるようにする。
      * **目標レベル:** 7

  * **タスク 78: プロシージャルマクロ (Procedural Macros) の概要**

      * **なぜ学ぶのか:** `macro_rules!` よりも強力なコード生成機能であり、`derive` マクロのように構造体や列挙型に自動的にコードを追加したり、属性マクロや関数型マクロを作成したりする方法の入り口を理解するため。
      * **何を学ぶのか:** プロシージャルマクロの3種類 (derive, attribute-like, function-like)、`syn` と `quote` クレートの役割 (ここでは深入りしない)。
      * **何をするのか:**
        1.  The Book のプロシージャルマクロの章を読む。
        2.  簡単な `derive` マクロの例 (例えば、構造体のフィールド名一覧を出力するようなもの) のコードを眺めて、どのように動作するかの雰囲気を掴む。(自分で書くのはレベル7では難しい)
      * **目標レベル:** 7

  * **タスク 79: `unsafe` ブロックの理解とFFIの初歩**

      * **なぜ学ぶのか:** Rust のメモリ安全保証を一時的に解除する必要があるケース (Cライブラリ呼び出し、低レベル操作など) と、その危険性を理解するため。
      * **何を学ぶのか:** `unsafe` キーワード、生ポインタ (`*const T`, `*mut T`) のデリファレンス、`extern "C"` による外部関数呼び出し。
      * **何をするのか:**
        1.  The Book の unsafe Rust の章を読む。
        2.  非常に簡単な C の関数 (例: `abs`) を呼び出すための `extern "C"` ブロックを書き、`unsafe` ブロック内で呼び出してみる (実際にCコンパイラとリンクしなくても、Rust側の宣言だけでも可)。
        3.  生ポインタの操作が `unsafe` であることを確認する。
      * **目標レベル:** 7

  * **タスク 80: クロスコンパイルの概要**

      * **なぜ学ぶのか:** 開発環境とは異なるターゲットプラットフォーム (例: Windows 上で Linux 用バイナリをビルド) 向けのバイナリを生成する方法の基本を知るため。
      * **何を学ぶのか:** `rustup target add`、`cargo build --target`。
      * **何をするのか:**
        1.  現在使用している OS とは異なるターゲット (例: `x86_64-unknown-linux-gnu` や `x86_64-pc-windows-gnu`) を `rustup target list` で確認。
        2.  興味のあるターゲットを `rustup target add <target-triple>` でインストールしてみる。
        3.  簡単な "Hello, world" プロジェクトを `--target <target-triple>` でビルドしてみる (リンカ等が必要な場合はエラーになるかもしれないが、手順は確認できる)。
      * **目標レベル:** 7

  * **タスク 81: ベンチマークの基礎 (`cargo bench` と `criterion`)**

      * **なぜ学ぶのか:** コードのパフォーマンスを測定し、ボトルネックを特定して最適化するための基本的な手法を学ぶため。
      * **何を学ぶのか:** `cargo bench` コマンド (nightly toolchain が必要)、`criterion` クレート。
      * **何をするのか:**
        1.  nightly ツールチェインをインストール (`rustup toolchain install nightly`) し、プロジェクトで使うように設定 (`rustup override set nightly`)。
        2.  `criterion` を `dev-dependencies` と `[[bench]]` セクションに `Cargo.toml` で設定。
        3.  `benches` ディレクトリに簡単なベンチマークテスト (例: 単純な計算関数の実行時間を測る) を `criterion` を使って書く。
        4.  `cargo bench` を実行し、結果を確認する。
      * **目標レベル:** 7

  * **タスク 82: 簡単なAI連携CLIツールの構想 (興味分野の反映)**

      * **なぜ学ぶのか:** 学習の集大成として、興味のある分野で実際に動くものを作ることで達成感を得て、さらなる学習意欲につなげるため。
      * **何を学ぶのか:** これまでの知識の応用、APIキーの安全な扱い (環境変数など)。
      * **何をするのか:**
        1.  利用したい生成AIのAPI (例: OpenAI, Anthropic, Gemini など) を選定する。
        2.  APIドキュメントを読み、リクエスト形式や認証方法を確認する。
        3.  非常にシンプルな機能 (例: プロンプトをコマンドライン引数で渡し、AIからの応答を表示する) を持つCLIツールを構想する。
        4.  必要なクレート (`reqwest`, `serde`, `clap`, `tokio`, `dotenvy` など) をリストアップする。
      * **目標レベル:** 7 (実践プロジェクト)

  * **タスク 83: AI連携CLIツールの実装 - APIリクエスト部分**

      * **何をするのか:**
        1.  APIキーを環境変数から読み込む処理を実装 (`dotenvy` クレートなど)。
        2.  `reqwest` を使ってAI APIへのリクエスト (POSTが多い) を非同期で送信する関数を実装。リクエストボディは `serde_json::json!` マクロや構造体シリアライズで作成。
        3.  レスポンスをJSONとしてパースし、必要な情報 (AIの生成テキストなど) を取り出す。
      * **目標レベル:** 7 (実践プロジェクト)

  * **タスク 84: AI連携CLIツールの実装 - CLIインターフェースと統合**

      * **何をするのか:**
        1.  `clap` を使ってコマンドライン引数 (プロンプトなど) を受け取る処理を実装。
        2.  メインの非同期関数内で、引数を元にAPIリクエスト関数を呼び出し、結果を表示する。
        3.  基本的なエラーハンドリング (`anyhow` など) を組み込む。
      * **目標レベル:** 7 (実践プロジェクト)

  * **フェーズ5 確認テストのテーマ:**

      * `async/await` を使った非同期関数の定義と呼び出し、`tokio` ランタイムの役割。
      * `futures::join!` や `tokio::spawn` を使った複数の非同期タスクの実行方法。
      * ワークスペースを使った複数クレートの管理方法。
      * Builder パターンのようなデザインパターンを Rust で実装する際のポイント。
      * `unsafe` ブロックがなぜ必要か、どのような場面で使うか、そのリスク。
      * `criterion` を使った簡単なベンチマークの書き方。
      * これまでの学習内容をGitリポジトリにコミットし、GitHub等にプッシュする。
      * 作成したAI連携CLIツールのデモンストレーションとコード説明。
